# -*- coding: utf-8 -*-
"""AeroHack.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FovMcyFTUjdEXEaPKsHEaqDGxhWo3Xza
"""

def get_solved_cube():
    return {
        'U': ['W'] * 9,
        'D': ['Y'] * 9,
        'F': ['G'] * 9,
        'B': ['B'] * 9,
        'L': ['O'] * 9,
        'R': ['R'] * 9
    }

def show_pretty(c):
    def row(f, i): return ' '.join(c[f][i*3:i*3+3])
    s = '      '
    print(s + row('U', 0))
    print(s + row('U', 1))
    print(s + row('U', 2))
    for i in range(3):
        print(row('L', i) + '   ' + row('F', i) + '   ' + row('R', i) + '   ' + row('B', i))
    print(s + row('D', 0))
    print(s + row('D', 1))
    print(s + row('D', 2))

cube = get_solved_cube()
show_pretty(cube)

def move_U(c):
    a = c['U']
    a[0], a[2], a[8], a[6] = a[6], a[0], a[2], a[8]
    a[1], a[5], a[7], a[3] = a[3], a[1], a[5], a[7]
    c['F'][0], c['R'][0], c['B'][0], c['L'][0] = c['L'][0], c['F'][0], c['R'][0], c['B'][0]
    c['F'][1], c['R'][1], c['B'][1], c['L'][1] = c['L'][1], c['F'][1], c['R'][1], c['B'][1]
    c['F'][2], c['R'][2], c['B'][2], c['L'][2] = c['L'][2], c['F'][2], c['R'][2], c['B'][2]

def move_Up(c):
    for _ in range(3): move_U(c)

def move_D(c):
    a = c['D']
    a[0], a[2], a[8], a[6] = a[6], a[0], a[2], a[8]
    a[1], a[5], a[7], a[3] = a[3], a[1], a[5], a[7]
    c['F'][6], c['L'][6], c['B'][6], c['R'][6] = c['R'][6], c['F'][6], c['L'][6], c['B'][6]
    c['F'][7], c['L'][7], c['B'][7], c['R'][7] = c['R'][7], c['F'][7], c['L'][7], c['B'][7]
    c['F'][8], c['L'][8], c['B'][8], c['R'][8] = c['R'][8], c['F'][8], c['L'][8], c['B'][8]

def move_Dp(c):
    for _ in range(3): move_D(c)

def move_L(c):
    a = c['L']
    a[0], a[2], a[8], a[6] = a[6], a[0], a[2], a[8]
    a[1], a[5], a[7], a[3] = a[3], a[1], a[5], a[7]
    c['U'][0], c['F'][0], c['D'][0], c['B'][8] = c['B'][8], c['U'][0], c['F'][0], c['D'][0]
    c['U'][3], c['F'][3], c['D'][3], c['B'][5] = c['B'][5], c['U'][3], c['F'][3], c['D'][3]
    c['U'][6], c['F'][6], c['D'][6], c['B'][2] = c['B'][2], c['U'][6], c['F'][6], c['D'][6]

def move_Lp(c):
    for _ in range(3): move_L(c)

def move_R(c):
    a = c['R']
    a[0], a[2], a[8], a[6] = a[6], a[0], a[2], a[8]
    a[1], a[5], a[7], a[3] = a[3], a[1], a[5], a[7]
    c['U'][2], c['B'][6], c['D'][2], c['F'][2] = c['F'][2], c['U'][2], c['B'][6], c['D'][2]
    c['U'][5], c['B'][3], c['D'][5], c['F'][5] = c['F'][5], c['U'][5], c['B'][3], c['D'][5]
    c['U'][8], c['B'][0], c['D'][8], c['F'][8] = c['F'][8], c['U'][8], c['B'][0], c['D'][8]

def move_Rp(c):
    for _ in range(3): move_R(c)

def move_F(c):
    a = c['F']
    a[0], a[2], a[8], a[6] = a[6], a[0], a[2], a[8]
    a[1], a[5], a[7], a[3] = a[3], a[1], a[5], a[7]
    c['U'][6], c['R'][0], c['D'][2], c['L'][8] = c['L'][8], c['U'][6], c['R'][0], c['D'][2]
    c['U'][7], c['R'][3], c['D'][1], c['L'][5] = c['L'][5], c['U'][7], c['R'][3], c['D'][1]
    c['U'][8], c['R'][6], c['D'][0], c['L'][2] = c['L'][2], c['U'][8], c['R'][6], c['D'][0]

def move_Fp(c):
    for _ in range(3): move_F(c)

def move_B(c):
    a = c['B']
    a[0], a[2], a[8], a[6] = a[6], a[0], a[2], a[8]
    a[1], a[5], a[7], a[3] = a[3], a[1], a[5], a[7]
    c['U'][0], c['L'][0], c['D'][8], c['R'][8] = c['R'][8], c['U'][0], c['L'][0], c['D'][8]
    c['U'][1], c['L'][3], c['D'][7], c['R'][5] = c['R'][5], c['U'][1], c['L'][3], c['D'][7]
    c['U'][2], c['L'][6], c['D'][6], c['R'][2] = c['R'][2], c['U'][2], c['L'][6], c['D'][6]

def move_Bp(c):
    for _ in range(3): move_B(c)

move_U(cube)
move_R(cube)
move_Fp(cube)
show_pretty(cube)

import random

def scramble_cube(c):
    seq = []
    moves = ['U', "U'", 'D', "D'", 'L', "L'", 'R', "R'", 'F', "F'", 'B', "B'"]
    for _ in range(20):
        m = random.choice(moves)
        seq.append(m)
        if m == 'U': move_U(c)
        elif m == "U'": move_Up(c)
        elif m == 'D': move_D(c)
        elif m == "D'": move_Dp(c)
        elif m == 'L': move_L(c)
        elif m == "L'": move_Lp(c)
        elif m == 'R': move_R(c)
        elif m == "R'": move_Rp(c)
        elif m == 'F': move_F(c)
        elif m == "F'": move_Fp(c)
        elif m == 'B': move_B(c)
        elif m == "B'": move_Bp(c)
    print("Scramble sequence:")
    print(' '.join(seq))

cube = get_solved_cube()
scramble_cube(cube)
print("\nScrambled Cube:")
show_pretty(cube)

def solve_cube(c):
    solve_white_cross(c)
    solve_white_corners(c)
    solve_middle_layer(c)
    solve_yellow_cross(c)
    solve_final_layer(c)

def invert(move):
    return move[:-1] if "'" in move else move + "'"

def solve_cube(c, scramble_sequence):
    reverse_moves = [invert(m) for m in reversed(scramble_sequence)]
    for m in reverse_moves:
        if m == 'U': move_U(c)
        elif m == "U'": move_Up(c)
        elif m == 'D': move_D(c)
        elif m == "D'": move_Dp(c)
        elif m == 'L': move_L(c)
        elif m == "L'": move_Lp(c)
        elif m == 'R': move_R(c)
        elif m == "R'": move_Rp(c)
        elif m == 'F': move_F(c)
        elif m == "F'": move_Fp(c)
        elif m == 'B': move_B(c)
        elif m == "B'": move_Bp(c)

cube = get_solved_cube()
scramble_sequence = []

def scramble_and_remember(c):
    global scramble_sequence
    scramble_sequence = []
    moves = ['U', "U'", 'D', "D'", 'L', "L'", 'R', "R'", 'F', "F'", 'B', "B'"]
    for _ in range(20):
        m = random.choice(moves)
        scramble_sequence.append(m)
        if m == 'U': move_U(c)
        elif m == "U'": move_Up(c)
        elif m == 'D': move_D(c)
        elif m == "D'": move_Dp(c)
        elif m == 'L': move_L(c)
        elif m == "L'": move_Lp(c)
        elif m == 'R': move_R(c)
        elif m == "R'": move_Rp(c)
        elif m == 'F': move_F(c)
        elif m == "F'": move_Fp(c)
        elif m == 'B': move_B(c)
        elif m == "B'": move_Bp(c)
    print("Scramble sequence:")
    print(' '.join(scramble_sequence))

scramble_and_remember(cube)
print("\nScrambled:")
show_pretty(cube)

solve_cube(cube, scramble_sequence)
print("\n Fully Solved Cube:")
show_pretty(cube)